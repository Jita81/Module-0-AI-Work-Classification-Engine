"""
Real-Time Service Pattern

Provides templates for WebSocket services, real-time data broadcasting,
and client SDK generation for live data applications.
"""

from typing import Dict, List, Any, Optional


class RealTimeServicePattern:
    """Pattern generator for real-time microservices."""
    
    def __init__(self):
        """Initialize real-time service pattern generator."""
        self.pattern_name = "realtime-service"
        self.supported_protocols = ["websocket", "sse", "socket.io"]
        self.client_sdk_languages = ["javascript", "python", "typescript"]
    
    def generate_websocket_server_template(self, service_name: str) -> str:
        """Generate WebSocket server template."""
        return f'''"""
WebSocket Server: {service_name}

Real-time WebSocket service with connection management and broadcasting.
Generated by Real-Time Service Pattern Generator.
"""

import asyncio
import json
import logging
from typing import Dict, Set, Any, Optional
from datetime import datetime
import websockets
from websockets.server import WebSocketServerProtocol

logger = logging.getLogger(__name__)


class {service_name}WebSocketServer:
    """
    Real-time WebSocket server for {service_name.lower()} service.
    
    Provides connection management, message broadcasting,
    and real-time data distribution.
    """
    
    def __init__(self, host: str = "localhost", port: int = 8765):
        """Initialize WebSocket server."""
        self.host = host
        self.port = port
        self.connections: Set[WebSocketServerProtocol] = set()
        self.rooms: Dict[str, Set[WebSocketServerProtocol]] = {{}}
        self.user_connections: Dict[str, WebSocketServerProtocol] = {{}}
        self.message_handlers = {{}}
        
        # Server statistics
        self.total_connections = 0
        self.messages_sent = 0
        self.messages_received = 0
        
        # Register default handlers
        self._register_default_handlers()
    
    def _register_default_handlers(self):
        """Register default message handlers."""
        self.message_handlers.update({{
            'join_room': self.handle_join_room,
            'leave_room': self.handle_leave_room,
            'ping': self.handle_ping,
            'get_stats': self.handle_get_stats
        }})
    
    async def start_server(self):
        """Start the WebSocket server."""
        logger.info(f"Starting WebSocket server on {{self.host}}:{{self.port}}")
        
        async with websockets.serve(
            self.handle_connection,
            self.host,
            self.port,
            ping_interval=20,
            ping_timeout=10
        ):
            logger.info("WebSocket server started successfully")
            await asyncio.Future()  # Run forever
    
    async def handle_connection(self, websocket: WebSocketServerProtocol, path: str):
        """Handle new WebSocket connection."""
        self.connections.add(websocket)
        self.total_connections += 1
        
        client_id = f"client_{{self.total_connections}}"
        logger.info(f"New connection: {{client_id}} from {{websocket.remote_address}}")
        
        try:
            # Send welcome message
            await self.send_to_client(websocket, {{
                'type': 'welcome',
                'client_id': client_id,
                'server_time': datetime.now().isoformat()
            }})
            
            # Handle messages
            async for message in websocket:
                await self.handle_message(websocket, message, client_id)
                
        except websockets.exceptions.ConnectionClosed:
            logger.info(f"Connection closed: {{client_id}}")
        except Exception as e:
            logger.error(f"Connection error: {{e}}")
        finally:
            await self.cleanup_connection(websocket, client_id)
    
    async def handle_message(self, websocket: WebSocketServerProtocol, 
                           message: str, client_id: str):
        """Handle incoming message from client."""
        try:
            data = json.loads(message)
            message_type = data.get('type')
            
            self.messages_received += 1
            logger.debug(f"Received {{message_type}} from {{client_id}}")
            
            # Route to appropriate handler
            if message_type in self.message_handlers:
                handler = self.message_handlers[message_type]
                await handler(websocket, data, client_id)
            else:
                # AI_TODO: Implement custom message handling
                await self.handle_custom_message(websocket, data, client_id)
                
        except json.JSONDecodeError:
            await self.send_error(websocket, "Invalid JSON message")
        except Exception as e:
            logger.error(f"Message handling error: {{e}}")
            await self.send_error(websocket, "Internal server error")
    
    async def handle_custom_message(self, websocket: WebSocketServerProtocol,
                                  data: Dict[str, Any], client_id: str):
        """
        Handle custom message types.
        
        AI_IMPLEMENTATION_REQUIRED: Implement specific message handling for {service_name}
        """
        message_type = data.get('type')
        
        # AI_TODO: Implement {service_name} specific message handling
        logger.info(f"Custom message {{message_type}} from {{client_id}}: {{data}}")
        
        # Echo back for now
        await self.send_to_client(websocket, {{
            'type': 'echo',
            'original_message': data,
            'processed_at': datetime.now().isoformat()
        }})
    
    async def handle_join_room(self, websocket: WebSocketServerProtocol,
                             data: Dict[str, Any], client_id: str):
        """Handle room join request."""
        room_name = data.get('room')
        if not room_name:
            await self.send_error(websocket, "Room name required")
            return
        
        if room_name not in self.rooms:
            self.rooms[room_name] = set()
        
        self.rooms[room_name].add(websocket)
        
        await self.send_to_client(websocket, {{
            'type': 'room_joined',
            'room': room_name,
            'members_count': len(self.rooms[room_name])
        }})
        
        # Notify other room members
        await self.broadcast_to_room(room_name, {{
            'type': 'user_joined',
            'client_id': client_id,
            'room': room_name
        }}, exclude=websocket)
    
    async def handle_leave_room(self, websocket: WebSocketServerProtocol,
                              data: Dict[str, Any], client_id: str):
        """Handle room leave request."""
        room_name = data.get('room')
        if room_name in self.rooms:
            self.rooms[room_name].discard(websocket)
            
            await self.send_to_client(websocket, {{
                'type': 'room_left',
                'room': room_name
            }})
            
            # Notify other room members
            await self.broadcast_to_room(room_name, {{
                'type': 'user_left',
                'client_id': client_id,
                'room': room_name
            }})
    
    async def handle_ping(self, websocket: WebSocketServerProtocol,
                         data: Dict[str, Any], client_id: str):
        """Handle ping request."""
        await self.send_to_client(websocket, {{
            'type': 'pong',
            'timestamp': datetime.now().isoformat()
        }})
    
    async def handle_get_stats(self, websocket: WebSocketServerProtocol,
                             data: Dict[str, Any], client_id: str):
        """Handle stats request."""
        stats = {{
            'total_connections': self.total_connections,
            'active_connections': len(self.connections),
            'messages_sent': self.messages_sent,
            'messages_received': self.messages_received,
            'rooms': {{room: len(members) for room, members in self.rooms.items()}}
        }}
        
        await self.send_to_client(websocket, {{
            'type': 'stats',
            'data': stats
        }})
    
    async def send_to_client(self, websocket: WebSocketServerProtocol, data: Dict[str, Any]):
        """Send message to specific client."""
        try:
            message = json.dumps(data)
            await websocket.send(message)
            self.messages_sent += 1
        except Exception as e:
            logger.error(f"Failed to send message: {{e}}")
    
    async def send_error(self, websocket: WebSocketServerProtocol, error_message: str):
        """Send error message to client."""
        await self.send_to_client(websocket, {{
            'type': 'error',
            'message': error_message,
            'timestamp': datetime.now().isoformat()
        }})
    
    async def broadcast_to_all(self, data: Dict[str, Any], exclude: Optional[WebSocketServerProtocol] = None):
        """Broadcast message to all connected clients."""
        if not self.connections:
            return
        
        connections = self.connections.copy()
        if exclude:
            connections.discard(exclude)
        
        message = json.dumps(data)
        
        # Send to all connections concurrently
        await asyncio.gather(
            *[self._safe_send(conn, message) for conn in connections],
            return_exceptions=True
        )
    
    async def broadcast_to_room(self, room_name: str, data: Dict[str, Any],
                              exclude: Optional[WebSocketServerProtocol] = None):
        """Broadcast message to all clients in a room."""
        if room_name not in self.rooms:
            return
        
        connections = self.rooms[room_name].copy()
        if exclude:
            connections.discard(exclude)
        
        message = json.dumps(data)
        
        await asyncio.gather(
            *[self._safe_send(conn, message) for conn in connections],
            return_exceptions=True
        )
    
    async def _safe_send(self, websocket: WebSocketServerProtocol, message: str):
        """Safely send message to websocket."""
        try:
            await websocket.send(message)
            self.messages_sent += 1
        except Exception as e:
            logger.debug(f"Failed to send to connection: {{e}}")
            # Connection will be cleaned up in handle_connection
    
    async def cleanup_connection(self, websocket: WebSocketServerProtocol, client_id: str):
        """Clean up connection and remove from all rooms."""
        self.connections.discard(websocket)
        
        # Remove from all rooms
        for room_name, room_connections in self.rooms.items():
            if websocket in room_connections:
                room_connections.remove(websocket)
                
                # Notify other room members
                await self.broadcast_to_room(room_name, {{
                    'type': 'user_disconnected',
                    'client_id': client_id,
                    'room': room_name
                }})
        
        # Remove from user connections
        for user_id, conn in list(self.user_connections.items()):
            if conn == websocket:
                del self.user_connections[user_id]
                break


class RealTimeDataBroadcaster:
    """Real-time data broadcaster for live updates."""
    
    def __init__(self, websocket_server: {service_name}WebSocketServer):
        """Initialize data broadcaster."""
        self.server = websocket_server
        self.data_sources = {{}}
        self.broadcasting = False
    
    async def start_broadcasting(self):
        """Start real-time data broadcasting."""
        self.broadcasting = True
        logger.info("Starting real-time data broadcasting")
        
        while self.broadcasting:
            try:
                # AI_TODO: Implement data source polling
                data = await self.fetch_real_time_data()
                
                if data:
                    await self.server.broadcast_to_all({{
                        'type': 'real_time_data',
                        'data': data,
                        'timestamp': datetime.now().isoformat()
                    }})
                
                await asyncio.sleep(1)  # Broadcast every second
                
            except Exception as e:
                logger.error(f"Broadcasting error: {{e}}")
                await asyncio.sleep(5)  # Back off on error
    
    async def fetch_real_time_data(self) -> Optional[Dict[str, Any]]:
        """
        Fetch real-time data from sources.
        
        AI_IMPLEMENTATION_REQUIRED: Implement data fetching for {service_name}
        """
        # AI_TODO: Implement real data fetching
        # For now, return mock data
        return {{
            'metric1': 42,
            'metric2': 'active',
            'timestamp': datetime.now().isoformat()
        }}
    
    def stop_broadcasting(self):
        """Stop data broadcasting."""
        self.broadcasting = False
        logger.info("Stopped real-time data broadcasting")


# AI_TODO: Add authentication and authorization
# AI_TODO: Add rate limiting per connection
# AI_TODO: Add message persistence for offline clients
'''
    
    def generate_client_sdk_template(self, service_name: str, language: str = "javascript") -> str:
        """Generate client SDK template."""
        if language.lower() == "javascript":
            return self._generate_javascript_sdk(service_name)
        elif language.lower() == "python":
            return self._generate_python_sdk(service_name)
        else:
            return self._generate_typescript_sdk(service_name)
    
    def _generate_javascript_sdk(self, service_name: str) -> str:
        """Generate JavaScript client SDK."""
        return f'''/**
 * {service_name} WebSocket Client SDK
 * 
 * JavaScript client for real-time communication with {service_name} service.
 * Generated by Real-Time Service Pattern Generator.
 */

class {service_name}Client {{
    constructor(url = 'ws://localhost:8765') {{
        this.url = url;
        this.websocket = null;
        this.connected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        
        this.eventHandlers = {{}};
        this.messageQueue = [];
        
        this.setupDefaultHandlers();
    }}
    
    setupDefaultHandlers() {{
        this.on('welcome', (data) => {{
            console.log('Connected to {service_name} server:', data);
            this.connected = true;
            this.reconnectAttempts = 0;
            this.flushMessageQueue();
        }});
        
        this.on('error', (data) => {{
            console.error('Server error:', data.message);
        }});
        
        this.on('pong', (data) => {{
            console.log('Ping response:', data.timestamp);
        }});
    }}
    
    async connect() {{
        try {{
            this.websocket = new WebSocket(this.url);
            
            this.websocket.onopen = () => {{
                console.log('WebSocket connection opened');
            }};
            
            this.websocket.onmessage = (event) => {{
                try {{
                    const data = JSON.parse(event.data);
                    this.handleMessage(data);
                }} catch (error) {{
                    console.error('Failed to parse message:', error);
                }}
            }};
            
            this.websocket.onclose = () => {{
                console.log('WebSocket connection closed');
                this.connected = false;
                this.attemptReconnect();
            }};
            
            this.websocket.onerror = (error) => {{
                console.error('WebSocket error:', error);
            }};
            
        }} catch (error) {{
            console.error('Failed to connect:', error);
            this.attemptReconnect();
        }}
    }}
    
    handleMessage(data) {{
        const type = data.type;
        
        if (this.eventHandlers[type]) {{
            this.eventHandlers[type].forEach(handler => {{
                try {{
                    handler(data);
                }} catch (error) {{
                    console.error(`Error in {{type}} handler:`, error);
                }}
            }});
        }} else {{
            console.log('Unhandled message type:', type, data);
        }}
    }}
    
    on(eventType, handler) {{
        if (!this.eventHandlers[eventType]) {{
            this.eventHandlers[eventType] = [];
        }}
        this.eventHandlers[eventType].push(handler);
    }}
    
    off(eventType, handler) {{
        if (this.eventHandlers[eventType]) {{
            const index = this.eventHandlers[eventType].indexOf(handler);
            if (index > -1) {{
                this.eventHandlers[eventType].splice(index, 1);
            }}
        }}
    }}
    
    send(data) {{
        if (this.connected && this.websocket.readyState === WebSocket.OPEN) {{
            this.websocket.send(JSON.stringify(data));
        }} else {{
            // Queue message for later sending
            this.messageQueue.push(data);
            console.log('Message queued (not connected):', data);
        }}
    }}
    
    flushMessageQueue() {{
        while (this.messageQueue.length > 0) {{
            const message = this.messageQueue.shift();
            this.send(message);
        }}
    }}
    
    joinRoom(roomName) {{
        this.send({{
            type: 'join_room',
            room: roomName
        }});
    }}
    
    leaveRoom(roomName) {{
        this.send({{
            type: 'leave_room',
            room: roomName
        }});
    }}
    
    ping() {{
        this.send({{
            type: 'ping',
            timestamp: new Date().toISOString()
        }});
    }}
    
    getStats() {{
        this.send({{
            type: 'get_stats'
        }});
    }}
    
    attemptReconnect() {{
        if (this.reconnectAttempts < this.maxReconnectAttempts) {{
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            
            console.log(`Attempting to reconnect ({{this.reconnectAttempts}}/{{this.maxReconnectAttempts}}) in {{delay}}ms`);
            
            setTimeout(() => {{
                this.connect();
            }}, delay);
        }} else {{
            console.error('Max reconnection attempts reached');
        }}
    }}
    
    disconnect() {{
        this.connected = false;
        if (this.websocket) {{
            this.websocket.close();
        }}
    }}
}}

// Usage example:
// const client = new {service_name}Client('ws://localhost:8765');
// client.on('real_time_data', (data) => console.log('Real-time data:', data));
// client.connect();

export default {service_name}Client;
'''
    
    def get_pattern_metadata(self) -> Dict[str, Any]:
        """Get metadata about the real-time service pattern."""
        return {
            'pattern_name': self.pattern_name,
            'pattern_type': 'realtime-service',
            'features': [
                'WebSocket server generation',
                'Real-time data broadcasting',
                'Connection management',
                'Room-based messaging',
                'Client SDK generation',
                'Automatic reconnection'
            ],
            'supported_protocols': self.supported_protocols,
            'client_sdk_languages': self.client_sdk_languages,
            'complexity': 'intermediate',
            'use_cases': [
                'Live chat applications',
                'Real-time dashboards',
                'Collaborative editing',
                'Live gaming features',
                'IoT data streaming'
            ]
        }
